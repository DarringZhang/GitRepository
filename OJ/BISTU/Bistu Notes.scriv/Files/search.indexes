<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="3"/>
        <Document ID="4">
            <Title>BistuAcmWeeklyTraining</Title>
        </Document>
        <Document ID="5"/>
        <Document ID="6"/>
        <Document ID="7">
            <Title>the 11th ICPC</Title>
        </Document>
        <Document ID="8">
            <Title>20190305</Title>
        </Document>
        <Document ID="9">
            <Title>A</Title>
        </Document>
        <Document ID="10">
            <Title>A</Title>
            <Text>#include&lt;iostream&gt;
using namespace std;

int main(void) {
	long long m,n,a;   //考虑相乘后结果就大于 10^9
	cin&gt;&gt;m&gt;&gt;n&gt;&gt;a;     //  int/long  2* 10 ^9   	longlong = 9 * 10^18    lld
	if(n%a == 0 &amp;&amp; m%a != 0 ){
		cout&lt;&lt; (m/a) * (n/a) +  n/a  &lt;&lt; endl; 
	}
	else if(m%a == 0 &amp;&amp; n%a != 0){
		cout&lt;&lt; (m/a) * (n/a) +  m/a  &lt;&lt; endl; 
	}
	else if(n%a != 0 &amp;&amp; m%a != 0){
		cout&lt;&lt; (m/a) * (n/a) +  m/a + n/a  + 1 &lt;&lt; endl;
	} 
	else if(n%a == 0 &amp;&amp; m%a == 0){
		cout&lt;&lt; (m/a) * (n/a)&lt;&lt;endl;
	}
	return 0;
}

—————————————————————严肃的分割线———————————————————————————————————-


Improving
/*
  简化上述四行代码为一行
        cout&lt;&lt;(a/c+(a%c!=0))*(b/c+(b%c!=0));
            展开： (a/c) * b/c +
            (a/c) * (b%c!=0) + 
            (b/c) * (a%c!=0) +
            (a%c!=0) * (b%c!=0)
 */

/*
    不间断输入：
    while(scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c) !=EOF){
    }
*/</Text>
        </Document>
        <Document ID="11">
            <Title>B</Title>
            <Text>哈哈哈哈</Text>
        </Document>
        <Document ID="12">
            <Title>E</Title>
            <Text>#include&lt;iostream&gt;
#include &lt;string.h&gt;      //引入函数 strlen ，但是接受的参数是char*,         string 也可使用.size()获得长度
using namespace std;

int main(void) {
    int n;
    int length;
    cin &gt;&gt; n;
    string s;
    while(n--){
        cin &gt;&gt; s;
        length = strlen(s.c_str());   //.c_str() 将string转换为char数组
                           if(length &lt;= 10){
            cout&lt;&lt;s&lt;&lt;endl;
        }
        else{
            cout&lt;&lt;s[0]&lt;&lt;length-2&lt;&lt; s[length-1]&lt;&lt;endl;
        }
    }

}

—————————————————————严肃的分割线———————————————————————————————————-


Improving
万能头文件  ：     #include&lt;bits/stdc++.h&gt;
     用字符串初始化字符数组时，系统会在字符数组的末尾自动加上一个字符&quot;\0&quot;，因此数组的大小比字符串中实际字符的个数大。
     如：sizeof(str1)=strlen(str1) +1</Text>
        </Document>
        <Document ID="13">
            <Title>C</Title>
            <Text>#include &lt;iostream&gt;
using namespace std;

/*用个结构体数组，结构体里面放出现的gram字符对和它出现的个数
难度在于 每次都要在结构体数组扫一遍，没有就添加
 还不如一开始就开26*26数组  表示A~Z 分别组合
 暴力扫描并找最大                                    ——————— 解题思路最重要
 */
 int main() {
     long long n;
     char a[110];
     cin &gt;&gt; n &gt;&gt; a;
     int gram[27][27] = {0};//初始化每对可能的gram数 = 0

     for(int i = 0; i &lt; 26 ; ++i){
         for(int j = 0 ; j &lt; 26 ; ++j){
             for(int k = 1; a[k] != '\0'; k++){ //一直读到字符串末尾
                if(a[k-1] -'A' == i &amp;&amp; a[k] - 'A' == j){ //将字符转换成数字和ij对应的A~Z字母比较
                    gram[i][j] ++;
                }
             }
         }
     }

     int big_count = 0;
     int i_index = 0;
     int j_index = 0;
     //暴力找出出现次数最多的gram
     for(int i = 0; i &lt; 26; ++i){
         for(int j = 0; j &lt; 26; j++){
             if(gram[i][j] &gt; big_count){
                 big_count  =  gram[i][j];
                 //记载出现次数最多的 gram 字母下标
                 i_index = i;
                 j_index = j;
             }
         }
     }
     cout &lt;&lt; (char) (i_index + 'A') &lt;&lt; (char) (j_index + 'A');//将数字转换成字符
    return 0;
}</Text>
        </Document>
        <Document ID="14">
            <Title>D</Title>
        </Document>
    </Documents>
</SearchIndexes>
